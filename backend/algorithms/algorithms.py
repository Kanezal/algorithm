def ford_Falkerson(graph, nR):
    """
    Алгоритм Форда-Фалкерсона для поиска максимального паросочетания в двудольном графе (реализация через DFS).
    graph: список списков, где graph[x] содержит индексы правых вершин, с которыми соединена левая вершина x.
    nR: количество правых вершин.
    Возвращает словарь с результатом для API.
    """
    # --- Инициализация ---
    # nL: Количество вершин в левой доле графа. Определяется по длине входного списка `graph`.
    nL = len(graph)
    # px: Список для хранения сопоставлений для левых вершин.
    # px[x] = y означает, что левая вершина x сопоставлена с правой вершиной y.
    # Изначально все вершины не сопоставлены (-1).
    px = [-1] * nL
    # py: Список для хранения сопоставлений для правых вершин.
    # py[y] = x означает, что правая вершина y сопоставлена с левой вершиной x.
    # Изначально все вершины не сопоставлены (-1).
    py = [-1] * nR

    # --- Вспомогательная функция DFS (поиск в глубину) ---
    # Эта функция пытается найти увеличивающий путь из вершины x.
    def dfs(x, visited):
        # Помечаем текущую левую вершину x как посещенную в текущем поиске DFS.
        # Это нужно, чтобы не заходить в одну и ту же вершину многократно в рамках одного поиска пути.
        visited[x] = True
        # Перебираем всех соседей (правые вершины y) для текущей левой вершины x.
        for y in graph[x]:
            # --- Случай 1: Правая вершина y свободна ---
            # Если правая вершина y еще не сопоставлена (py[y] == -1),
            # то мы нашли увеличивающий путь длины 1.
            if py[y] == -1:
                # Сопоставляем x с y.
                px[x] = y
                py[y] = x
                # Увеличивающий путь найден.
                return True
            # --- Случай 2: Правая вершина y занята ---
            # Если правая вершина y уже сопоставлена с какой-то левой вершиной x2 (py[y] == x2).
            else:
                # Получаем левую вершину x2, с которой сопоставлена y.
                x2 = py[y]
                # Если x2 еще не была посещена в текущем DFS И
                # если мы можем найти увеличивающий путь, начиная от x2 (рекурсивный вызов dfs),
                # то мы можем "переключить" сопоставление.
                if not visited[x2] and dfs(x2, visited):
                    # "Переключаем" сопоставление: теперь x сопоставлена с y.
                    px[x] = y
                    py[y] = x
                    # Увеличивающий путь найден.
                    return True
        # Если не удалось найти увеличивающий путь из вершины x.
        return False

    # --- Основной цикл алгоритма ---
    # Продолжаем искать увеличивающие пути, пока они находятся.
    found_path = True
    while found_path:
        found_path = False
        # `visited` для каждого нового поиска увеличивающего пути должен быть сброшен.
        # Этот массив отслеживает посещенные вершины *в рамках одного вызова DFS* для поиска одного пути.
        visited = [False] * nL
        # Пытаемся найти увеличивающий путь из каждой свободной левой вершины.
        for x in range(nL):
            # Если левая вершина x еще не сопоставлена (px[x] == -1).
            if px[x] == -1:
                # Пытаемся найти увеличивающий путь, начиная с x.
                if dfs(x, visited):
                    # Если путь найден, устанавливаем флаг, чтобы продолжить основной цикл.
                    found_path = True
    # --- Формирование результата ---
    # Собираем все найденные пары (сопоставления).
    # matches будет списком пар [левая_вершина, правая_вершина].
    matches = [[i, px[i]] for i in range(nL) if px[i] != -1]
    # Возвращаем результат в формате, удобном для API.
    return {
        "max_matching": len(matches),  # Размер максимального паросочетания
        "matches": matches,            # Список ребер паросочетания
        "left_nodes": list(range(nL)), # Список левых вершин
        "right_nodes": list(range(nR)) # Список правых вершин
    }


def lagrange_interpolation(points, x):
    """
    Интерполяция Лагранжа для вычисления значения полинома в точке x.
    points: список точек (кортежей или списков) вида [(x0, y0), (x1, y1), ..., (xn-1, yn-1)].
    x: точка, в которой нужно вычислить значение интерполяционного полинома.
    Возвращает словарь с результатом для API.
    """
    # --- Инициализация и проверки ---
    # n: количество заданных точек.
    n = len(points)
    # Если точек нет, интерполяция невозможна.
    if n == 0:
        return {"error": "Необходима хотя бы одна точка"}

    # Проверяем, что все x-координаты точек уникальны.
    # Это важное условие для корректности интерполяции Лагранжа.
    x_coords = [p[0] for p in points]
    if len(set(x_coords)) != len(x_coords):
        return {"error": "X-координаты точек должны быть уникальными"}

    # result: здесь будет накапливаться результат вычисления полинома L(x).
    result = 0.0

    # --- Вычисление значения полинома ---
    # Основной цикл по формуле Лагранжа: L(x) = sum_{i=0}^{n-1} (yi * li(x))
    # где li(x) - базисный полином Лагранжа.
    for i in range(n):
        # xi, yi - координаты текущей i-й точки.
        xi, yi = points[i]
        # term: текущий член суммы (yi * li(x)). Начинаем с yi.
        term = yi

        # Внутренний цикл для вычисления базисного полинома li(x):
        # li(x) = product_{j=0, j!=i}^{n-1} ((x - xj) / (xi - xj))
        for j in range(n):
            if i != j: # Условие j != i
                xj = points[j][0] # x-координата j-й точки
                # Проверка деления на ноль (xi - xj).
                # В данном контексте, если xi == xj при i != j, это ошибка входных данных (неуникальные x),
                # но проверка уникальности x_coords выше должна это предотвратить.
                # Однако, если бы той проверки не было, здесь стоило бы добавить обработку ZeroDivisionError.
                term *= (x - xj) / (xi - xj)
        
        # Добавляем вычисленный член (yi * li(x)) к общей сумме.
        result += term

    # --- Построение строки с полиномом (для наглядности) ---
    # Эта часть не влияет на вычисленное значение `result`, а лишь формирует
    # строковое представление полинома.
    polynomial_terms = [] # Список для хранения строковых представлений каждого члена полинома
    for i in range(n):
        xi, yi = points[i]
        # Если yi равен 0, то соответствующий член полинома равен 0 и его можно пропустить.
        if yi == 0:
            continue
            
        # term_parts: части для формирования строкового представления i-го члена.
        # Начинаем с yi (коэффициент).
        term_parts = [f"{yi:.2f}"] # Форматируем yi до двух знаков после запятой
        # Формируем множители (x - xj) / (xi - xj)
        for j in range(n):
            if i != j:
                xj = points[j][0]
                denominator = xi - xj # Знаменатель (xi - xj)
                # Формируем строковое представление дроби.
                # Если xj = 0, то (x - 0) = x.
                if xj == 0:
                    term_parts.append(f"x/{denominator:.2f}")
                else:
                    term_parts.append(f"(x - {xj:.2f})/{denominator:.2f}")
        
        # Объединяем части i-го члена знаком умножения.
        polynomial_terms.append(" * ".join(term_parts))

    # Объединяем все члены полинома знаком сложения.
    # Если список polynomial_terms пуст (например, все yi=0), полином равен "0".
    polynomial = " + ".join(polynomial_terms) if polynomial_terms else "0"

    # --- Формирование результата ---
    return {
        "value": result,             # Вычисленное значение полинома в точке x
        "x": x,                      # Точка x, для которой производились вычисления
        "polynomial": polynomial,    # Строковое представление полинома
        "degree": n - 1 if n > 0 else 0, # Степень полинома (n-1 для n точек)
        "points": points             # Исходные точки
    }


def find_continuous_common_increasing_subsequence(sequences):
    """
    Находит наибольшую непрерывную общую возрастающую подпоследовательность для четырех и более последовательностей.
    sequences: список последовательностей (списков чисел).
    Возвращает словарь с результатом для API.
    """
    # --- Проверка входных данных ---
    # Алгоритм предназначен для 4 или более последовательностей.
    if len(sequences) < 4:
        return {"error": "Должно быть 4 или более последовательностей"}

    # --- Вспомогательная функция: является ли `sub` непрерывной подпоследовательностью `seq` ---
    def is_continuous_subsequence(sub, seq):
        n = len(sub) # Длина подпоследовательности
        # Перебираем все возможные начальные позиции для `sub` в `seq`.
        for i in range(len(seq) - n + 1):
            # Если срез `seq` совпадает с `sub`, то `sub` является непрерывной подпоследовательностью.
            if seq[i:i+n] == sub:
                return True
        return False # Если не найдено совпадений.

    # --- Вспомогательная функция: является ли `sub` общей непрерывной подпоследовательностью для всех `list_of_seqs` ---
    def is_common_continuous_subsequence(sub, list_of_seqs):
        # Проверяем для каждой последовательности в `list_of_seqs`.
        for seq in list_of_seqs:
            # Если `sub` не является непрерывной подпоследовательностью хотя бы для одной `seq`,
            # то она не является общей.
            if not is_continuous_subsequence(sub, seq):
                return False
        return True # Если `sub` найдена во всех последовательностях.

    # --- Вспомогательная функция: является ли последовательность `seq` возрастающей ---
    def is_increasing(seq):
        # Перебираем элементы, начиная со второго.
        for i in range(1, len(seq)):
            # Если текущий элемент не строго больше предыдущего, последовательность не возрастающая.
            if seq[i] <= seq[i-1]:
                return False
        return True # Если все проверки пройдены.

    # --- Основная логика поиска ---
    # Находим самую короткую последовательность из входного списка.
    # Поиск подпоследовательностей будет производиться на основе этой самой короткой,
    # так как общая подпоследовательность не может быть длиннее самой короткой из исходных.
    min_seq = min(sequences, key=len)
    # `others` - список всех остальных последовательностей (кроме `min_seq`).
    others = [seq for seq in sequences if seq is not min_seq]

    all_subsequences = [] # Список для хранения всех возрастающих непрерывных подпоследовательностей из `min_seq`.
    n = len(min_seq)

    # Генерируем все возможные непрерывные подпоследовательности из `min_seq`.
    # Перебираем возможные длины подпоследовательностей (от 1 до n).
    for length in range(1, n + 1):
        # Перебираем возможные начальные индексы для подпоследовательности данной длины.
        for start in range(n - length + 1):
            sub = min_seq[start:start+length] # Получаем срез - текущую подпоследовательность.
            # Проверяем, является ли она возрастающей.
            if is_increasing(sub):
                all_subsequences.append(sub) # Добавляем в список, если возрастающая.

    # Сортируем найденные подпоследовательности по длине в убывающем порядке.
    # Это позволит нам найти *наибольшую* общую подпоследовательность первой.
    all_subsequences.sort(key=len, reverse=True)

    # Ищем первую (самую длинную) подпоследовательность, которая является общей для `others`.
    for sub in all_subsequences:
        if is_common_continuous_subsequence(sub, others):
            # Если найдена, возвращаем результат.
            return {
                "length": len(sub),      # Длина найденной подпоследовательности
                "subsequence": sub,      # Сама подпоследовательность
                "sequences": sequences   # Исходные последовательности (для информации)
            }

    # Если ни одна общая возрастающая непрерывная подпоследовательность не найдена.
    return {"length": 0, "subsequence": [], "sequences": sequences}


def malgrange_scc(adj_matrix):
    """
    Поиск компонент сильной связности (SCC) в графе по матрице смежности.
    Используется алгоритм, основанный на поиске достижимых вершин в прямом и обратном графе.
    adj_matrix: квадратная матрица смежности (список списков), где adj_matrix[i][j] = 1 если есть ребро из i в j.
    Возвращает словарь с результатом для API: список компонент и их количество.
    """
    # --- Инициализация ---
    # n: количество вершин в графе.
    n = len(adj_matrix)
    # Строим обратный (транспонированный) граф `reverse`.
    # Если в исходном графе было ребро i -> j, то в обратном будет j -> i.
    reverse = [[0]*n for _ in range(n)] # Создаем пустую матрицу смежности для обратного графа.
    for i in range(n):
        for j in range(n):
            if adj_matrix[i][j]: # Если есть ребро от i к j в исходном графе
                reverse[j][i] = 1 # то в обратном графе есть ребро от j к i.

    # visited: список для отслеживания вершин, которые уже были отнесены к какой-либо SCC.
    # Изначально все вершины не посещены.
    visited = [False]*n
    # scc: список для хранения найденных компонент сильной связности.
    # Каждая компонента будет списком вершин.
    scc = []

    # --- Вспомогательная функция BFS (поиск в ширину) ---
    # Эта функция находит все вершины, достижимые из `start` в графе, заданном `matrix`,
    # при условии, что эти вершины разрешены (`allowed`).
    def bfs(start, matrix, allowed):
        q = [start] # Очередь для BFS, начинаем со стартовой вершины.
        reached = [False]*n # Список для отметки достигнутых вершин в текущем BFS.
        reached[start] = True # Стартовая вершина достигнута.

        while q: # Пока очередь не пуста
            cur = q.pop(0) # Извлекаем текущую вершину из очереди.
            # Перебираем всех возможных соседей `nb` для `cur`.
            for nb in range(n):
                # Если есть ребро от `cur` к `nb` в `matrix`,
                # И вершина `nb` разрешена для посещения (`allowed[nb]`),
                # И вершина `nb` еще не была достигнута в этом BFS.
                if matrix[cur][nb] and allowed[nb] and not reached[nb]:
                    reached[nb] = True # Помечаем `nb` как достигнутую.
                    q.append(nb) # Добавляем `nb` в очередь.
        return reached # Возвращаем список достигнутых вершин.

    # --- Основной цикл поиска SCC ---
    # Перебираем все вершины графа.
    for v in range(n):
        # Если вершина `v` еще не была отнесена ни к одной SCC.
        if not visited[v]:
            # `allowed` - маска вершин, которые еще не включены в SCC и могут быть рассмотрены.
            allowed = [not visited[k] for k in range(n)]

            # `fwd`: множество вершин, достижимых из `v` в исходном графе.
            # Поиск ведется только среди `allowed` вершин.
            fwd  = bfs(v, adj_matrix,  allowed)
            # `back`: множество вершин, из которых достижима `v` в исходном графе
            # (что эквивалентно достижимым из `v` в обратном графе `reverse`).
            # Поиск также ведется только среди `allowed` вершин.
            back = bfs(v, reverse,     allowed)

            # Компонента сильной связности, содержащая `v`, состоит из вершин `k`, которые:
            # 1. Еще не были отнесены к SCC (`not visited[k]`).
            # 2. Достижимы из `v` в прямом графе (`fwd[k]`).
            # 3. Из них достижима `v` в прямом графе (т.е. `v` достижима из `k` в обратном графе, `back[k]`).
            comp = [k for k in range(n)
                    if not visited[k] and fwd[k] and back[k]]

            # Все вершины, вошедшие в найденную компоненту `comp`, помечаются как посещенные.
            for k in comp:
                visited[k] = True
            # Добавляем найденную компоненту в список SCC.
            scc.append(comp)

    # --- Формирование результата ---
    return {"scc": scc, "count": len(scc)} # Возвращаем список SCC и их количество.