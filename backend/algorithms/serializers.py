from rest_framework import serializers

# --- Сериализатор для алгоритма Форда-Фалкерсона ---
class FordFulkersonSerializer(serializers.Serializer):
    """
    Сериализатор для валидации входных данных алгоритма Форда-Фалкерсона.
    Ожидает поле 'graph' - список списков целых чисел.
    """
    # `graph`: Поле для представления графа.
    # Это список (ListField), где каждый элемент является другим списком (child=serializers.ListField).
    # Внутренние списки содержат целые числа (child=serializers.IntegerField(min_value=0)),
    # представляющие индексы вершин, и они должны быть неотрицательными.
    graph = serializers.ListField(
        child=serializers.ListField(
            child=serializers.IntegerField(min_value=0) # Каждая вершина - неотрицательное целое число.
        ),
        help_text="Список смежности графа для поиска максимального паросочетания. " \
                  "Пример: [[0, 1], [2], [3], [1]] означает, что левая вершина 0 " \
                  "соединена с правыми 0 и 1, левая 1 с правой 2 и т.д."
    )
    # Поле `nR` (количество правых вершин) было убрано из сериализатора,
    # так как оно теперь вычисляется автоматически во view-функции на основе `graph`.


# --- Сериализатор для интерполяции Лагранжа ---
class LagrangeSerializer(serializers.Serializer):
    """
    Сериализатор для валидации входных данных алгоритма интерполяции Лагранжа.
    Ожидает:
    - 'points': список точек (каждая точка - список из двух чисел [x, y]).
    - 'x': число, для которого вычисляется значение полинома.
    """
    # `points`: Список точек для интерполяции.
    # Каждая точка - это список (child=serializers.ListField) из двух чисел с плавающей точкой (child=serializers.FloatField()).
    # Каждая точка должна содержать ровно 2 элемента (min_length=2, max_length=2) - координату x и координату y.
    points = serializers.ListField(
        child=serializers.ListField(
            child=serializers.FloatField(), # Координаты x и y - числа с плавающей точкой.
            min_length=2, # Каждая точка должна иметь x и y.
            max_length=2  # Не более двух координат на точку.
        ),
        help_text="Список точек в формате [[x1, y1], [x2, y2], ...]. Минимум одна точка."
    )
    # `x`: Значение, для которого нужно вычислить интерполяционный полином.
    # Это число с плавающей точкой.
    x = serializers.FloatField(help_text="Значение x, для которого вычисляется значение полинома Лагранжа.")


# --- Сериализатор для старого LCIS (2 последовательности) ---
# Этот сериализатор может быть использован, если бы была отдельная view для двух последовательностей.
# В текущей реализации lcis_view обрабатывает и старый, и новый формат.
class LCISSerializer(serializers.Serializer):
    """
    Сериализатор для валидации входных данных алгоритма LCIS (Наибольшая Общая Возрастающая Подпоследовательность)
    для двух последовательностей (старый вариант).
    Ожидает:
    - 'sequence1': первая последовательность чисел.
    - 'sequence2': вторая последовательность чисел.
    """
    # `sequence1`: Первая последовательность целых чисел.
    sequence1 = serializers.ListField(
        child=serializers.IntegerField(), # Элементы последовательности - целые числа.
        help_text="Первая последовательность целых чисел."
    )
    # `sequence2`: Вторая последовательность целых чисел.
    sequence2 = serializers.ListField(
        child=serializers.IntegerField(), # Элементы последовательности - целые числа.
        help_text="Вторая последовательность целых чисел."
    )


# --- Сериализатор для LCIS (>=4 последовательностей) ---
class ContinuousCommonIncreasingSubsequenceSerializer(serializers.Serializer):
    """
    Сериализатор для валидации входных данных алгоритма поиска
    наибольшей *непрерывной* общей возрастающей подпоследовательности
    для четырех и более последовательностей.
    Ожидает:
    - 'sequences': список, содержащий как минимум 4 последовательности чисел.
    """
    # `sequences`: Список последовательностей.
    # Это список (ListField), где каждый элемент - это другая последовательность (список целых чисел).
    # Должно быть как минимум 4 таких последовательности (min_length=4).
    sequences = serializers.ListField(
        child=serializers.ListField(
            child=serializers.IntegerField(), # Каждая последовательность состоит из целых чисел.
            help_text="Одна из числовых последовательностей."
        ),
        min_length=2, # Минимальное количество последовательностей. Алгоритм требует >=4, но view обрабатывает и 2.
                      # Если строго для >=4, то здесь должно быть min_length=4.
                      # Текущая lcis_view поддерживает и 2 посл. для обратной совместимости.
        help_text="Список из >=2 (рекомендуется >=4) последовательностей для поиска общей непрерывной возрастающей подпоследовательности."
    )


# --- Сериализатор для алгоритма Мальгранжа (SCC) ---
class MalgrangeSCCSerializer(serializers.Serializer):
    """
    Сериализатор для валидации входных данных алгоритма Мальгранжа
    (поиск компонент сильной связности).
    Ожидает:
    - 'adj_matrix': матрица смежности графа.
    """
    # `adj_matrix`: Матрица смежности графа.
    # Это список (ListField), где каждый элемент - это строка матрицы (тоже список целых чисел).
    # Предполагается, что матрица квадратная и содержит 0 или 1.
    adj_matrix = serializers.ListField(
        child=serializers.ListField(
            child=serializers.IntegerField(min_value=0, max_value=1), # Элементы матрицы - 0 или 1 (хотя алгоритм может обработать и веса > 1 как наличие ребра).
            help_text="Строка матрицы смежности (список 0 или 1)."
        ),
        help_text="Матрица смежности графа для поиска компонент сильной связности. " \
                  "Пример: [[0, 1, 0], [0, 0, 1], [1, 0, 0]] для графа-цикла 0->1->2->0."
    )
    # Дополнительно можно добавить валидацию, что матрица квадратная
    # и что длины всех внутренних списков одинаковы, во view или в методе validate() сериализатора.